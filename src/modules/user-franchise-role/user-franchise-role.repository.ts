import { PipelineStage, Types } from "mongoose";
import { MSG_BUSINESS } from "../../core/constants";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { BaseRepository } from "../../core/repository";
import { formatItemsQuery } from "../../core/utils";
import { SearchItemDto, SearchPaginationItemDto } from "./dto/search.dto";
import { IUserFranchiseRole } from "./user-franchise-role.interface";
import UserFranchiseRoleSchema from "./user-franchise-role.model";

export class UserFranchiseRoleRepository extends BaseRepository<IUserFranchiseRole> {
  constructor() {
    super(UserFranchiseRoleSchema);
  }

  public async getItem(id: string): Promise<IUserFranchiseRole | null> {
    const query = [
      ...this.buildQueryPipeline({
        _id: new Types.ObjectId(id),
        is_deleted: false,
      }),
      { $limit: 1 },
    ];
    const result = await this.model.aggregate(query);
    return result[0] || null;
  }

  public async getItems(model: SearchPaginationItemDto): Promise<{ data: any[]; total: number }> {
    const searchCondition = {
      ...new SearchItemDto(),
      ...model.searchCondition,
    };

    const { user_id, franchise_id, role_id, is_deleted } = searchCondition;
    const { pageNum, pageSize } = model.pageInfo;

    let matchQuery: Record<string, any> = {};

    // common + dynamic filters
    matchQuery = formatItemsQuery(matchQuery, {
      is_deleted,
      user_id,
      franchise_id,
      role_id,
    });

    const skip = (pageNum - 1) * pageSize;

    try {
      const query: PipelineStage[] = [
        ...this.buildQueryPipeline(matchQuery),
        {
          $facet: {
            data: [{ $sort: { created_at: -1 } }, { $skip: skip }, { $limit: pageSize }],
            total: [{ $count: "count" }],
          },
        },
      ];

      const result = await this.model.aggregate(query);

      return {
        data: result[0].data,
        total: result[0].total[0]?.count || 0,
      };
    } catch (error) {
      console.error(error);
      throw new HttpException(HttpStatus.BadRequest, MSG_BUSINESS.DATABASE_QUERY_FAILED);
    }
  }

  public async getAllRolesByUserId(userId: string): Promise<any[]> {
    try {
      const matchQuery = {
        user_id: new Types.ObjectId(userId),
        is_deleted: false,
      };

      const pipeline: PipelineStage[] = [
        ...this.buildQueryPipeline(matchQuery),

        // üî• JOIN ROLE
        {
          $lookup: {
            from: "roles",
            localField: "role_id",
            foreignField: "_id",
            as: "role",
          },
        },
        { $unwind: { path: "$role", preserveNullAndEmptyArrays: true } },

        // üî• JOIN FRANCHISE
        {
          $lookup: {
            from: "franchises",
            localField: "franchise_id",
            foreignField: "_id",
            as: "franchise",
          },
        },
        { $unwind: { path: "$franchise", preserveNullAndEmptyArrays: true } },

        // üî• JOIN USER
        {
          $lookup: {
            from: "users",
            localField: "user_id",
            foreignField: "_id",
            as: "user",
          },
        },
        { $unwind: { path: "$user", preserveNullAndEmptyArrays: true } },

        // üî• PROJECT ƒê√öNG FORMAT EM MU·ªêN
        {
          $project: {
            id: "$_id",
            is_active: 1,
            is_deleted: 1,
            created_at: 1,
            updated_at: 1,
            note: 1,

            franchise_id: "$franchise._id",
            franchise_code: "$franchise.code",
            franchise_name: "$franchise.name",

            role_id: "$role._id",
            role_code: "$role.code",
            role_name: "$role.name",

            user_id: "$user._id",
            user_name: "$user.name",
            user_email: "$user.email",
          },
        },

        { $sort: { created_at: -1 } },
      ];

      return await this.model.aggregate(pipeline);
    } catch (error) {
      console.error(error);
      throw new HttpException(HttpStatus.BadRequest, MSG_BUSINESS.DATABASE_QUERY_FAILED);
    }
  }

  private buildQueryPipeline(matchQuery: Record<string, any>): PipelineStage[] {
    return [
      // 1Ô∏è‚É£ Filter
      { $match: matchQuery },

      // 2Ô∏è‚É£ Lookup related data
      {
        $lookup: {
          from: "franchises",
          localField: "franchise_id",
          foreignField: "_id",
          as: "franchise",
        },
      },
      {
        $lookup: {
          from: "users",
          localField: "user_id",
          foreignField: "_id",
          as: "user",
        },
      },
      {
        $lookup: {
          from: "roles",
          localField: "role_id",
          foreignField: "_id",
          as: "role",
        },
      },

      // 3Ô∏è‚É£ Unwind
      { $unwind: { path: "$franchise", preserveNullAndEmptyArrays: true } },
      { $unwind: { path: "$user", preserveNullAndEmptyArrays: true } },
      { $unwind: { path: "$role", preserveNullAndEmptyArrays: true } },

      // 4Ô∏è‚É£ Project
      {
        $project: {
          franchise_id: 1,
          franchise_code: "$franchise.code",
          franchise_name: "$franchise.name",

          user_id: 1,
          user_name: "$user.name",
          user_email: "$user.email",

          role_id: 1,
          role_code: "$role.code",
          role_name: "$role.name",

          note: 1,
          is_active: 1,
          is_deleted: 1,
          created_at: 1,
          updated_at: 1,
        },
      },
    ];
  }
}
